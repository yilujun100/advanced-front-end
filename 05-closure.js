// JavaScript 中的闭包是相当重要的概念，并且与作用域相关知识的指向密切相关，在大厂的前端面试过程中经常会被提及。

// 作用域基本介绍
// JavaScript 的作用域通俗来讲，就是指变量能够被访问到的范围，在 JavaScript 中作用域也分为好几种，ES5 之前
// 只有全局作用域和函数作用域两种。ES6 出现之后，又新增了块级作用域，下面我们就来看下这三种作用域的概念，为闭包
// 的学习打好基础。
// 全局作用域
// 在编程语言中，不论 Java 也好，JavaScript 也罢，变量一般都会分为全局变量和局部变量两种。那么变量定义在函数
// 外部，代码最前面的一般情况下都是全局变量。
// 在 JavaScript 中，全局变量是挂载在 window 对象下的变量，所以在网页中的任何位置你都可以使用并且访问到这个
// 全局变量。
var globalName = 'global';
function getName() {
    console.log(globalName);
    var name = 'inner';
    console.log(name);
}
getName();
console.log(name);
console.log(globalName);
function setName() {
    vName = 'setName';
}
setName();
console.log(vName);
console.log(window.vName);
// globalName 这个变量无论在什么地方都是可以被访问到的，所以它就是全局变量。而在 getName 函数中作为局部变量的 name
// 变量是不具备这种能力的。
// 如果在 JavaScript 中所有没有经过定义，而直接被赋值的变量默认就是一个全局变量，比如上面代码中 setName 函数里面的
// vName 变量一样。
// 全局变量也是拥有全局的作用域，无论你在何处都可以使用它，在浏览器控制台输入 window.vName 的时候，就可以访问到 window
// 上所有全局变量。
// 当然全局作用域有相应的缺点，我们定义很多全局变量的时候，会容易引起变量命名的冲突，所以在定义变量的时候应该注意作用域
// 的问题。

// 函数作用域
// 在 JavaScript 中，函数中定义的变量叫作函数变量，这个时候只能在函数内部才能访问到它，所以它的作用域也就是函数的内部，
// 称为函数作用域。
function getName() {
    var name = 'inner';
    console.log(name);
}
getName();
console.log(name);
// name 这个变量是在 getName 函数中进行定义的，所以 name 是一个局部的变量，它的作用域就是在 getName 这个函数里边，
// 也称作函数作用域。
// 除了这个函数内部，其他地方都是不能访问到它的。同时，当这个函数被执行完之后，这个局部变量也相应会被销毁。所以在 getName
// 函数外面 name 是访问不到的。

// 块级作用域
// ES6 中新增了块级作用域，最直接的表现就是新增的 let 关键词，使用 let 关键词定义的变量只能在块级作用域中被访问，有“暂时性死区”
// 的特点，也就是说这个变量在定义之前是不能被使用的。
// 在 JS 编码过程中 if 语句及 for 语句后面 {...} 这里面所包括的，就是块级作用域。
console.log(a);
if (true) {
    let a = '123';
    console.log(a);
}
console.log(a);

// 什么是闭包？
// 红宝书闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。
// MDN: 一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你
// 可以在一个内层函数中访问到其外层函数的作用域。
// 乍一看上面的两个比较官方的定义，很难让人理解清晰，尤其是MDN的关于闭包的定义，真的比较让人“头晕”，那么现在就和你说说我是
// 怎么理解的。
// 闭包的基本概念
// 通俗讲：闭包其实就是一个可以访问其他函数内部变量的函数。即一个定义在函数内部的函数，或者直接说闭包是个内嵌函数也可以。
// 因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部
// 访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。
function fun1() {
    var a = 1;
    return function() {
        console.log(a);
    };
}
fun1();
var result = fun1();
result();
// a 变量作为一个 fun1 函数的内部变量，正常情况下作为函数内的局部变量，是无法被外部访问到的。但是通过闭包，我们最后还是可以
// 拿到 a 变量的值。
// 闭包产生的原因
// 前面介绍了作用域的概念，那么你还需要明白作用域链的基本概念。其实很简单，当访问一个变量时，代码解释器会首先在当前的作用域查找，
// 如果没找到，就去父级作用域去查找，直到找到该变量或者不存在父级作用域中，这样的链路就是作用域链。
// 需要注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。
var a = 1;
function fun1() {
    var a = 2;
    function fun2() {
        var a = 3;
        console.log(a);
    }
}
// 什么是作用域链，即当前函数一般都会存在上层函数的作用域的引用，那么它们就形成了一条作用域链。
// 由此可见，闭包产生的本质就是：当前环境中存在指向父级作用域的引用。
// 闭包的本质，只需要让父级作用域的引用存在即可。

// 闭包的使用场景
// 1.返回一个函数
// 2.在定时器、事件监听、Ajax请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。
// 定时器
setTimeout(function handler() {
    console.log('1');
}, 1000);
// 事件监听
$('#app').click(function() {
    console.log('Event Listener');
});
// 3.作为函数参数传递的形式
var a = 1;
function foo() {
    var a = 2;
    function baz() {
        console.log(a);
    }
    bar(baz);
}
function bar(fn) {
    fn(); // 这就是闭包
}
foo();
// 4.IIFE(立即执行函数)，创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量
var a = 2;
(function IIFE() {
    console.log(a);
})();
// IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免外界访问此 IIFE 中的变量，
// 而且也不会污染全局作用域，我们经常能在高级的 JavaScript 编程中看见此类函数。

// 如何解决循环输出问题？
for (var i = 1; i <= 5; i++) {
    setTimeout(function() {
        console.log(i);
    }, 0);
}
// 上面这段代码执行之后，从控制台执行的结果可以看出来，结果输出的是5个6，那么一般面试官都会先问为什么都是6？我想让你实现
// 输出1、2、3、4、5 的话怎么办呢？
// setTimeout 为宏任务，由于 JS 中单线程 EventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout
// 中的回调才一次执行。
// 因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window,变量 i 为 window 上的全局变量，开始执行 setTieout
// 之前变量 i 已经就是6了，因此最后输出的连续就都是6。
// 那么如何按顺序依次输出1、2、3、4、5
// 利用 IIFE
// 可以利用 IIFE(立即执行函数)，当每次 for 循环时，把此时的变量 i 传递到定时器中，然后执行
for (var i = 1; i <= 5; i++) {
    (function(j) {
        setTimeout(function() {
            console.log(j);
        }, 0)
    })(i)
}
// 使用 ES6 中的let
for (let i = 1; i <= 5; i++) {
    setTimeout(function() {
        console.log(i);
    }, 0)
}
// 通过 let 定义变量的方式，重新定义 i 变量，则可以用最少的改动成本，解决该问题。
// 定时器传入第三个参数
// setTimeout 作为经常使用的定时器，它是存在第三个参数的，日常工作中我们经常使用的一般是前两个，一个是回调函数，另外一个是时间，
// 第三个参数用的比较少。那么结合第三个参数，调整完之后的代码如下：
for (var i = 1; i <= 5; i++) {
    setTimeout(function(j) {
        console.log(j);
    }, 0, i);
}
// 第三个参数的传递，可以改变 setTimeout 的执行逻辑，从而实现我们想要的结果，这也是一种解决循环输出问题的途径。

// 总结
// 闭包的使用在日常的 JavaScript 编程中经常出现，使用的场景特别多而且复杂。由于闭包会使一些变量一直保存在内存中不会自动释放，
// 所以如果大量使用的话就会消耗大量内存，从而影响网页性能。因此，你更应该深入理解闭包的原理，从而保证交付的代码性能更好。